package com.ui.telemetry;

import com.Context;
import com.remote.Setting;
import com.remote.SettingList;

import java.util.*;

import javax.swing.*;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.CellEditorListener;
import javax.swing.table.TableCellEditor;

import java.awt.Component;

/**
 * @author Chris Park @ Infinetix Corp
 * Date: 3-22-21
 * Description: A custom editor that manipulates JSliders in table cells.
 * This editor is responsible for the mapping and representation of the
 * tables underlying SettingPercentge values (integers) and how they are
 * displayed to the user.
 */
public class SliderEditor extends JSlider implements TableCellEditor {
	Context context;
	protected Vector<CellEditorListener> listenerList;
	
	//Slider State Tracking Vars
	protected int startingValue;
	protected int previousChangeValue;
	protected int targetRow;
	
	protected boolean editing;
	
	
	
	
	public SliderEditor(Context context, JTable table) {
		super(SwingConstants.HORIZONTAL);
		this.context = context;
		listenerList = new Vector<CellEditorListener>();
		previousChangeValue = -1;
		targetRow = -1;
		
		addChangeListener(new ChangeListener() {
			@Override
			public void stateChanged(ChangeEvent event) {
				int row = table.getSelectedRow();
				
				//Don't use a row value that doesn't exist. (Table not init'd)
				if(row < 0) {
					return;
				}
				
				//Edge Case: Ignore false change values of zero triggered when
				//switching between sliders.
				if(row != targetRow) {
					System.err.println(
							"    SliderEditor - Previous slider false 0 value ignored.");
					return;
				}
				
				//Edge Case: Ignore duplicate slider values generated by
				//mouse up events
				if(previousChangeValue == getValue()) {
					
					System.err.println(
							"    SliderEditor - Duplicate value, should update now");
					return;
				}
				
				
				System.err.println("    Changing Row: " + row 
						+ ", Current Percentage: " + getValue());
				Setting setting = context.settingList.get(row);
				
				
				
				//Edge cases:
				
				
					//Releasing a slider sends a duplicate of the last value changed.
						//Check that previous value doesn't equal current value before
						//attempting to do anything with it.
				
						//**OR wait for that duplicate value if it's guaranteed (seems
						//consistend so far), and then when we see it, we know we have
						//our new percentage value to calculate the new setting for.
				
					//Click into a different slider sets slider model for previous slider
						//one more time. Then one more change event is fired for that
						//previous slider as a 0 value before picking up on the new ones. 
						//Will need a way to catch this last change event and discard
						//that reset value.
				
						//Possible solution:
							//Store a changes row number (need init value?)
							//if the row on the next change event is not equal to
							//the previous, don't use/set the percentage.
				
				
				
				
				
				//Update the previous value to account for duplication edge case
				previousChangeValue = getValue();
			}
		});
	
	}

	/**
	 * Handles the standard functionality of the editor. Determining
	 * how the incoming value and position should be operated on.
	 * @param table - The table this editor is attached to
	 * @param value - The value to be manipulated/changed by this event.
	 * @param isSelected - Whether or not the active cell is selected
	 * @param row - The row location of this cell in the table.
	 * @param column - The column location of this cell in the table.
	 * @return - Component
	 */
	@Override
	public Component getTableCellEditorComponent(JTable table, Object value,
			boolean isSelected, int row, int column) {
		targetRow = row;
		
		System.err.println("SliderEditor - in component editing row " + row);
		
//		if(this.getValueIsAdjusting()) {
//			System.err.println("Adjusting...");
//		}
//		this.setValueIsAdjusting(true);
		
		
		if(value instanceof SettingPercentage) {
			System.err.println("SliderEditor - Setting Percentage for row " + row);
			setValue(((SettingPercentage) value).getPercentage());
			
//			Setting setting = context.settingList.get(row);
//			
//			int percentage 	= ((SettingPercentage) value).getPercentage();
//			System.err.println("Percentage: " + percentage);
//			
//			float min 		= setting.getMin();
//			System.err.println("Min: " + min);
//			
//			float max 		= setting.getMax();
//			System.err.println("Max: " + max);
//			
//			float range 	= (max - min);
//			System.err.println("Range: " + range);
//			
//			float settingValue = ((percentage * range) / 100) + min;
//			System.err.println("New setting value is: " + settingValue);
//			
		}
		else {
			setValue(0);
		}
		
		startingValue = getValue();
		editing = true;

		return this;
	}
	
	/**
	 * Gets the value currently held by the cell editor.
	 * @return - Object
	 */
	@Override
	public Object getCellEditorValue() {
		return new SettingPercentage(getValue());
	}
	
	/**
	 * Returns whether or not a cell is editable.
	 * @param eventObj - The event that triggered this check
	 * @return - boolean
	 */
	@Override
	public boolean isCellEditable(EventObject eventObj) {
		return true;
	}
	
	/**
	 * Returns whether or not a cell should be selected
	 * @param eventObj - The event that triggered this check
	 * @return - boolean
	 */
	@Override
	public boolean shouldSelectCell(EventObject eventObj) {
		return true;
	}
	
	/**
	 * Stops cell editing and notifies all listeners
	 * @return - boolean
	 */
	@Override
	public boolean stopCellEditing() {
		fireEditingStopped();
		editing = false;
		return true;
	}

	/**
	 * Cancels cell editing and notifies all listeners.
	 */
	@Override
	public void cancelCellEditing() {
		fireEditingCanceled();
		editing = false;
	}
	
	/**
	 * Adds a cell listener to the internally kept list
	 * @param listener - The listener to add
	 */
	@Override
	public void addCellEditorListener(CellEditorListener listener) {
		listenerList.addElement(listener);
	}
	
	/**
	 * Removes a listener from the internally kept list.
	 * @param listener - The listener to remove.
	 */
	@Override
	public void removeCellEditorListener(CellEditorListener listener) {
		listenerList.removeElement(listener);
	}

	/**
	 * Iterates through the list of listeners for this editors
	 * change events and notifies them that editing has been canceled.
	 */	
	protected void fireEditingCanceled() {
		setValue(startingValue);
		ChangeEvent changeEvent = new ChangeEvent(this);
		for (int i = listenerList.size() - 1; i >= 0; i--) {
			((CellEditorListener) listenerList.elementAt(i)).editingCanceled(changeEvent);
		}
	}
	
	/**
	 * Iterates through the list of listeners for this editors
	 * change events and notifies them that editing has stopped.
	 */
	protected void fireEditingStopped() {		
		ChangeEvent changeEvent = new ChangeEvent(this);
		for (int i = listenerList.size() - 1; i >= 0; i--) {
			((CellEditorListener) listenerList.elementAt(i)).editingStopped(changeEvent);
		}
	}
}
