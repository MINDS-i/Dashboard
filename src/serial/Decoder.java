package com.serial;

import java.util.*;
import java.io.InputStream;

interface PacketReader{
    /**
     * Give this message reader a chance to claim a particular packet
     *     data is the first byte of a packet's data section
     *     should return -1 if the packet is not claimed,
     *       or the maximum packet length if claimed
     */
    public int claim(byte data);
    /**
     * When a claimed packet has finished transmitting, it will be passed
     *   to handle
     */
    public void handle(byte[] data);
}

interface Checksum{
    /**
     * return a byte[] containing the checksum of the plaintext array
     */
    public byte[] calc(byte[] plaintext);
    /**
     * return the length of a sum generated by this object
     */
    public int length();
}

/**
 * Decodes packets of the form <header+><signifier>data<checksum+><footer+>
 */
public class Decoder{
    private final InputStream input;
    private final byte[] header;
    private final byte[] footer;
    private final Checksum sum;
    private final List<PacketReader> readers = new LinkedList<PacketReader>();

    private static class Packet{
        int startPos;
        int maxLength;
        PacketReader claimee;
        Packet(int sPos, int mLen, PacketReader claimer) {
            startPos = sPos;
            maxLength = mLen;
            claimee = claimer;
        }
    }
    private List<Packet> foundHeaders = new ArrayList<Packet>();
    private List<Byte>   buffer = new ArrayList<Byte>();

    public Decoder(InputStream input, byte[] head, byte[] tail, Checksum sum){
        this.input  = input;
        this.header = head;
        this.footer = tail;
        this.sum    = sum;
    }
    /**
     * Read new bytes from the input stream, dispatching messages as it goes
     */
    public void update(){
        //accept bytes from input
        int oldPos = buffer.size()-1;
        while(true){
            byte data;
            try{
                data = (byte) input.read();
            } catch (Exception e) {
                e.printStackTrace();
                break;
            }
            if(data == -1) break;
            buffer.add(data);
        }
        parse(oldPos);
    }

    private void parse(int oldPos){
        //because the header includes one byte beyond the "header" buffer,
        //it isn't matched until the header was matched one byte ago
        for(int i=oldPos+1; i<buffer.size(); i++){
            if (match(header, i-1)) foundHeader(i);
            if (match(footer, i  )) foundFooter(i);
        }
        cleanBuffers();
    }

    //check if pattern appears in buffer, ending at searchPos
    private boolean match(byte[] pattern, int searchPos){
        if(searchPos <= pattern.length-1) return false;
        for(int i=0; i<pattern.length; i++){
            if(buffer.get(searchPos-i) != pattern[pattern.length-1-i]) return false;
        }
        return true;
    }

    //see if any reader claims the coming packet
    //if so, add to the header list
    private void foundHeader(int pos){
        byte sig = buffer.get(pos);
        for(PacketReader r : readers) {
            int len = r.claim(sig);
            if(len != -1) {
                foundHeaders.add(new Packet(pos, len, r));
                return;
            }
        }
    }

    //check for valid checksum with possible headers
    //then send to handler on a match
    private void foundFooter(int pos){
        int footerPos = pos - (footer.length-1);
        int checksumPos = footerPos - (sum.length()-1);
        for(int i=0; i < foundHeaders.size(); i++){
            Packet p = foundHeaders.get(i);
            //find and extract the relevant data
            List<Byte> subBuffer = buffer.subList(p.startPos, checksumPos);
            if(subBuffer.size() > p.maxLength) continue;
            byte[] data = new byte[subBuffer.size()];
            for(int b=0; b<subBuffer.size(); b++) data[b] = subBuffer.get(b);
            //calculate and match checksum
            byte[] checksum = sum.calc(data);
            if(match(checksum, footerPos)){
                //remove older headers and call handler
                foundHeaders.subList(0, i+1).clear(); //exclusive on second arg
                p.claimee.handle(data);
                return;
            }
        }
    }

    private void cleanBuffers(){
        int retained = Math.max(buffer.size() - header.length, 0);
        for(Packet p : foundHeaders){
            retained = Math.min(retained, p.startPos);
        }
        buffer.subList(0, retained).clear();
    }

    public void close(){
        try{
            input.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void addPacketReader(PacketReader reader){
        readers.add(reader);
    }

    public void removePacketReader(PacketReader reader){
        readers.remove(reader);
    }
}
